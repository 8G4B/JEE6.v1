import discord
from discord.ext import commands, tasks
from datetime import datetime, timedelta
import json
import os
import secrets
import random
import threading
import asyncio
import time
from typing import Optional, Tuple, List, Dict, Callable, Any
from shared.database import (
    get_user_balance, set_user_balance,
    get_jackpot, set_jackpot,
    get_cooldown, set_cooldown,
    get_sorted_balances
)

class GamblingConfig:
    MIN_BET = 100
    MIN_JACKPOT_BET = 1000
    MAX_BET = 100_000_000_000_000

    INITIAL_JACKPOT = 1_000_000

    JACKPOT_WIN_COOLDOWN = 1800
    GAME_COOLDOWN = 5
    WORK_COOLDOWN = 60

    INCOME_TAX_BRACKETS = [
        (1_000_000_000_000_000, 0.45),
        (  500_000_000_000_000, 0.42),
        (  300_000_000_000_000, 0.40),
        (  150_000_000_000_000, 0.38),
        (   88_000_000_000_000, 0.35),
        (   50_000_000_000_000, 0.24),
        (   14_000_000_000_000, 0.15),
        (    5_000_000_000_000, 0.06),
        (0, 0)
    ]

    SECURITIES_TRANSACTION_TAX_BRACKETS = [
        (30_000_000_000_000, 0.02),
        (10_000_000_000_000, 0.01),
        (0, 0.005)
    ]

    GIFT_TAX_BRACKETS = [
        (30_000_000_000_000, 0.15),
        (10_000_000_000_000, 0.125),
        ( 5_000_000_000_000, 0.10),
        ( 1_000_000_000_000, 0.075),
        (0, 0.05)
    ]

    GAME_MULTIPLIER_RANGES = {
        'coin': (1.0, 1.2),
        'dice': (4.6, 5.7),
        'blackjack': (1.2, 1.5),
        'baccarat': (1.2, 1.5),
        'indian_poker': (1.0, 1.2)
    }   

    WORK_REWARD_RANGE = (100, 2000)

    RESET_TIMES = [
        (7, 30),
        (12, 30),
        (18, 30)
    ]




class GamblingEmbed:
    @staticmethod
    def create_error_embed(description: str) -> discord.Embed:
        return discord.Embed(
            title="‚ùó Ïò§Î•ò",
            description=description,
            color=discord.Color.red()
        )

    @staticmethod
    def create_game_embed(
        author_name: str,
        is_correct: bool,
        guess: str,
        result: str,
        bet: Optional[int] = None,
        winnings: Optional[int] = None,
        balance: Optional[int] = None,
        game_type: Optional[str] = None,
        tax: Optional[int] = None
    ) -> discord.Embed:
        title = f"{'ü™ô' if game_type == 'coin' else 'üé≤' if game_type == 'dice' else 'üé∞'} {author_name} {'ÎßûÏùå „Ñπ„Öà„Ñ∑' if is_correct else 'ÌãÄÎ¶º„Öã'}"
        color = discord.Color.green() if is_correct else discord.Color.red()

        description_parts = [
            f"- ÏòàÏ∏°: {guess}",
            f"- Í≤∞Í≥º: {result}"
        ]

        if bet is not None and winnings is not None and balance is not None:
            if is_correct:
                total_winnings = winnings + (tax or 0)
                multiplier = total_winnings / bet
                description_parts.extend([
                    f"## ÏàòÏùµ: {bet:,}Ïõê √ó {multiplier:.2f} = {winnings:,}Ïõê(ÏÑ∏Í∏à: {tax:,}Ïõê)" if tax else f"## ÏàòÏùµ: {bet:,}Ïõê √ó {multiplier:.2f} = {winnings:,}Ïõê",
                    f"- Ïû¨ÏÇ∞: {balance:,}Ïõê(+{winnings:,})"
                ])
            else:
                description_parts.extend([
                    f"## ÏàòÏùµ: {bet:,}Ïõê √ó -1 = {winnings:,}Ïõê",
                    f"- Ïû¨ÏÇ∞: {balance:,}Ïõê({winnings:,})"
                ])

        return discord.Embed(
            title=title,
            description="\n".join(description_parts),
            color=color
        )

class GamblingService:
    def __init__(self):
        self._locks = {}
        self._lock_lock = asyncio.Lock()

    async def _get_lock(self, user_id: int) -> asyncio.Lock:
        async with self._lock_lock:
            if user_id not in self._locks:
                self._locks[user_id] = asyncio.Lock()
            return self._locks[user_id]

    async def get_balance(self, user_id: int) -> int:
        return await get_user_balance(user_id)

    async def set_balance(self, user_id: int, amount: int) -> None:
        await set_user_balance(user_id, amount)

    async def add_balance(self, user_id: int, amount: int) -> None:
        current_balance = await self.get_balance(user_id)
        await self.set_balance(user_id, current_balance + amount)

    async def subtract_balance(self, user_id: int, amount: int) -> None:
        current_balance = await self.get_balance(user_id)
        await self.set_balance(user_id, current_balance - amount)

    async def get_jackpot(self) -> int:
        return await get_jackpot()

    async def set_jackpot(self, amount: int) -> None:
        await set_jackpot(amount)

    async def add_jackpot(self, amount: int) -> None:
        current_jackpot = await self.get_jackpot()
        await self.set_jackpot(current_jackpot + amount)

    async def subtract_jackpot(self, amount: int) -> None:
        current_jackpot = await self.get_jackpot()
        await self.set_jackpot(current_jackpot - amount)

    async def get_sorted_balances(self) -> List[Tuple[int, int]]:
        return await get_sorted_balances()

    def calculate_gift_tax(self, amount: int) -> int:
        for threshold, rate in GamblingConfig.GIFT_TAX_BRACKETS:
            if amount > threshold:
                return int(amount * rate)
        return 0

    def validate_bet(self, bet: Optional[int], user_id: Optional[int] = None) -> Optional[discord.Embed]:
        if bet is None:
            return GamblingEmbed.create_error_embed("Î≤†ÌåÖ Í∏àÏï°ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.")
        if bet < GamblingConfig.MIN_BET:
            return GamblingEmbed.create_error_embed(f"ÏµúÏÜå {GamblingConfig.MIN_BET:,}Ïõê Ïù¥ÏÉÅ Î≤†ÌåÖÌï¥Ï£ºÏÑ∏Ïöî.")
        if bet > GamblingConfig.MAX_BET:
            return GamblingEmbed.create_error_embed(f"ÏµúÎåÄ {GamblingConfig.MAX_BET:,}ÏõêÍπåÏßÄ Î≤†ÌåÖÌï† Ïàò ÏûàÏñ¥Ïöî.")
        return None

class GamblingManager:
    def __init__(self):
        self.active_games: Dict[int, str] = {}
        self.lock = threading.RLock()
        
    def start_game(self, user_id: int, game_type: str) -> bool:
        with self.lock:
            if user_id in self.active_games:
                return False
            self.active_games[user_id] = game_type
            return True
            
    def end_game(self, user_id: int) -> None:
        with self.lock:
            self.active_games.pop(user_id, None)
            
    def get_active_game(self, user_id: int) -> Optional[str]:
        with self.lock:
            return self.active_games.get(user_id)

class Gambling(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.cooldowns: Dict[str, datetime] = {}
        self.game_manager = GamblingManager()
        self.gambling_service = GamblingService()
        self.blackjack_players = set()
        self.baccarat_players = set()
        self.indian_poker_players = set()
        self.coin_players = set()
        self.dice_players = set()
        self.reset_jackpot.start()

    def _check_game_cooldown(self, user_id: int, game_type: str) -> Optional[discord.Embed]:
        current_time = datetime.now()
        cooldown_key = f"{game_type}_{user_id}"
        last_used = self.cooldowns.get(cooldown_key)

        if last_used:
            cooldown_time = (GamblingConfig.JACKPOT_WIN_COOLDOWN if game_type == "jackpot_win" 
                           else GamblingConfig.GAME_COOLDOWN)
            if (current_time - last_used).total_seconds() < cooldown_time:
                remaining = cooldown_time - int((current_time - last_used).total_seconds())
                minutes = remaining // 60
                seconds = remaining % 60

                time_str = f"{minutes}Î∂Ñ {seconds}Ï¥à" if minutes > 0 else f"{seconds}Ï¥à"

                return GamblingEmbed.create_error_embed(f"{time_str} ÌõÑÏóê Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.")

        if game_type != "jackpot_win":
            self.cooldowns[cooldown_key] = current_time
        return None

    @tasks.loop(seconds=1)
    async def reset_jackpot(self):
        now = datetime.now()
        for hour, minute in GamblingConfig.RESET_TIMES:
            if now.hour == hour and now.minute == minute:
                await self.gambling_service.set_jackpot(GamblingConfig.INITIAL_JACKPOT)
                return discord.Embed(
                    title="üé∞ Ïû≠Ìåü Î¶¨ÏÖã",
                    description="Ïû≠ÌåüÏù¥ 100ÎßåÏõêÏúºÎ°ú Î¶¨ÏÖãÎêòÏóàÏäµÎãàÎã§.",
                    color=discord.Color.green()
                )

    async def _play_game(
        self,
        author_id: int,
        author_name: str,
        guess: str,
        result: str,
        bet: int,
        game_type: str
    ) -> discord.Embed:
        lock = await self.gambling_service._get_lock(author_id)
        try:
            async with lock:
                is_correct = (guess == result)
                if is_correct:
                    multiplier = random.uniform(*GamblingConfig.GAME_MULTIPLIER_RANGES[game_type])
                    winnings = int(bet * multiplier)
                    tax = self.gambling_service.calculate_tax(winnings, game_type)
                    winnings_after_tax = winnings - tax
                    await self.gambling_service.add_balance(author_id, winnings_after_tax)
                else:
                    winnings = -bet
                    tax = None
                    await self.gambling_service.subtract_balance(author_id, bet)

                return GamblingEmbed.create_game_embed(
                    author_name=author_name,
                    is_correct=is_correct,
                    guess=guess,
                    result=result,
                    bet=bet,
                    winnings=winnings_after_tax if is_correct else winnings,
                    balance=await self.gambling_service.get_balance(author_id),
                    game_type=game_type,
                    tax=tax
                )
        except Exception as e:
            logger.error(f"Error in _play_game: {e}")
            return GamblingEmbed.create_error_embed("Í≤åÏûÑ ÏßÑÌñâ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.")

    @commands.command(name="ÎèÑÎ∞ï.ÎèôÏ†Ñ", description="ÎèôÏ†Ñ ÎçòÏßÄÍ∏∞")
    async def coin(self, ctx, bet: str = None):
        if not self.game_manager.start_game(ctx.author.id, "coin"):
            await ctx.reply(embed=GamblingEmbed.create_error_embed("Ïù¥ÎØ∏ Îã§Î•∏ Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§."))
            return

        if cooldown_embed := self._check_game_cooldown(ctx.author.id, "coin"):
            await ctx.reply(embed=cooldown_embed)
            self.game_manager.end_game(ctx.author.id)
            return

        try:
            bet = int(bet) if bet != "Ïò¨Ïù∏" else await self.gambling_service.get_balance(ctx.author.id)
        except (ValueError, TypeError):
            bet = None

        if error_embed := self.gambling_service.validate_bet(bet, ctx.author.id):
            await ctx.reply(embed=error_embed)
            self.game_manager.end_game(ctx.author.id)
            return

        if bet > await self.gambling_service.get_balance(ctx.author.id):
            await ctx.reply(embed=GamblingEmbed.create_error_embed("ÎèàÏù¥ Î∂ÄÏ°±Ìï¥..."))
            self.game_manager.end_game(ctx.author.id)
            return

        embed = discord.Embed(
            title=f"ü™ô {ctx.author.name}Ïùò ÎèôÏ†Ñ Í≤åÏûÑ",
            description="ÏïûÎ©¥ ÎòêÎäî Îí∑Î©¥ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî",
            color=discord.Color.blue()
        )
        embed.add_field(name="ÏÑ†ÌÉù", value="‚≠ï ÏïûÎ©¥ / ‚ùå Îí∑Î©¥", inline=False)

        game_message = await ctx.reply(embed=embed)
        await game_message.add_reaction("‚≠ï")
        await game_message.add_reaction("‚ùå")

        def check(reaction, user):
            return (user == ctx.author and 
                   str(reaction.emoji) in ["‚≠ï", "‚ùå"] and 
                   reaction.message.id == game_message.id)

        try:
            reaction, user = await self.bot.wait_for('reaction_add', timeout=30.0, check=check)
            guess = "Ïïû" if str(reaction.emoji) == "‚≠ï" else "Îí§"
            result = secrets.choice(["Ïïû", "Îí§"])

            embed = await self._play_game(
                ctx.author.id,
                ctx.author.name,
                guess,
                result,
                bet,
                "coin"
            )
            await game_message.edit(embed=embed)

        except asyncio.TimeoutError:
            embed = GamblingEmbed.create_error_embed("30Ï¥à ÎèôÏïà ÏùëÎãµÏù¥ ÏóÜÏñ¥ Ï∑®ÏÜåÎêêÏñ¥Ïöî")
            await game_message.edit(embed=embed)

        finally:
            self.game_manager.end_game(ctx.author.id)

    @commands.command(name="ÎèÑÎ∞ï.Ï£ºÏÇ¨ÏúÑ", description="Ï£ºÏÇ¨ÏúÑ")
    async def dice(self, ctx, bet: str = None):
        if not self.game_manager.start_game(ctx.author.id, "dice"):
            await ctx.reply(embed=GamblingEmbed.create_error_embed("Ïù¥ÎØ∏ Îã§Î•∏ Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§."))
            return

        if cooldown_embed := self._check_game_cooldown(ctx.author.id, "dice"):
            await ctx.reply(embed=cooldown_embed)
            self.game_manager.end_game(ctx.author.id)
            return

        try:
            bet = int(bet) if bet != "Ïò¨Ïù∏" else await self.gambling_service.get_balance(ctx.author.id)
        except (ValueError, TypeError):
            bet = None

        if error_embed := self.gambling_service.validate_bet(bet, ctx.author.id):
            await ctx.reply(embed=error_embed)
            self.game_manager.end_game(ctx.author.id)
            return

        if bet > await self.gambling_service.get_balance(ctx.author.id):
            await ctx.reply(embed=GamblingEmbed.create_error_embed("ÎèàÏù¥ Î∂ÄÏ°±Ìï¥..."))
            self.game_manager.end_game(ctx.author.id)
            return

        embed = discord.Embed(
            title=f"üé≤ {ctx.author.name}Ïùò Ï£ºÏÇ¨ÏúÑ Í≤åÏûÑ",
            description="1Î∂ÄÌÑ∞ 6ÍπåÏßÄ Ïà´ÏûêÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî",
            color=discord.Color.blue()
        )
        embed.add_field(name="ÏÑ†ÌÉù", value="1Ô∏è‚É£ 2Ô∏è‚É£ 3Ô∏è‚É£ 4Ô∏è‚É£ 5Ô∏è‚É£ 6Ô∏è‚É£", inline=False)

        game_message = await ctx.reply(embed=embed)
        reactions = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£"]
        for reaction in reactions:
            await game_message.add_reaction(reaction)

        def check(reaction, user):
            return (user == ctx.author and 
                   str(reaction.emoji) in reactions and 
                   reaction.message.id == game_message.id)

        try:
            reaction, user = await self.bot.wait_for('reaction_add', timeout=30.0, check=check)
            guess = str(reactions.index(str(reaction.emoji)) + 1)
            result = secrets.choice([str(i) for i in range(1, 7)])

            embed = await self._play_game(
                ctx.author.id,
                ctx.author.name,
                guess,
                result,
                bet,
                "dice"
            )
            await game_message.edit(embed=embed)

        except asyncio.TimeoutError:
            embed = GamblingEmbed.create_error_embed("30Ï¥à ÎèôÏïà ÏùëÎãµÏù¥ ÏóÜÏñ¥ Ï∑®ÏÜåÎêêÏñ¥Ïöî")
            await game_message.edit(embed=embed)

        finally:
            self.game_manager.end_game(ctx.author.id)

    @commands.command(name="ÎèÑÎ∞ï.Ïû≠Ìåü", description="Ïû≠Ìåü")
    async def jackpot(self, ctx, bet: str = None):
        if not self.game_manager.start_game(ctx.author.id, "jackpot"):
            await ctx.reply(embed=GamblingEmbed.create_error_embed("Ïù¥ÎØ∏ Îã§Î•∏ Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§."))
            return

        if cooldown_embed := self._check_game_cooldown(ctx.author.id, "jackpot"):
            await ctx.reply(embed=cooldown_embed)
            self.game_manager.end_game(ctx.author.id)
            return

        if cooldown_embed := self._check_game_cooldown(ctx.author.id, "jackpot_win"):
            await ctx.reply(embed=cooldown_embed)
            self.game_manager.end_game(ctx.author.id)
            return

        try:
            bet = int(bet) if bet != "Ïò¨Ïù∏" else await self.gambling_service.get_balance(ctx.author.id)
        except (ValueError, TypeError):
            bet = None

        if bet is None or bet < GamblingConfig.MIN_JACKPOT_BET:
            await ctx.reply(embed=GamblingEmbed.create_error_embed("1,000Ïõê Ïù¥ÏÉÅ Î≤†ÌåÖÌïòÏÑ∏Ïöî"))
            self.game_manager.end_game(ctx.author.id)
            return

        if bet >= GamblingConfig.MAX_BET:
            await ctx.reply(embed=GamblingEmbed.create_error_embed("100Ï°∞Ïõê Ïù¥ÏÉÅ Î≤†ÌåÖÌï† Ïàò ÏóÜÏäµÎãàÎã§"))
            self.game_manager.end_game(ctx.author.id)
            return

        lock = await self.gambling_service._get_lock(ctx.author.id)
        async with lock:
            current_balance = await self.gambling_service.get_balance(ctx.author.id)
            min_bet = current_balance // 100

            if bet > current_balance:
                await ctx.reply(embed=GamblingEmbed.create_error_embed("ÎèàÏù¥ Î∂ÄÏ°±Ìï¥..."))
                self.game_manager.end_game(ctx.author.id)
                return

            if bet < min_bet:
                await ctx.reply(embed=GamblingEmbed.create_error_embed(
                    f"ÌòÑÏû¨ Ïû¨ÏÇ∞Ïùò 1% Ïù¥ÏÉÅ Î≤†ÌåÖÌïòÏÑ∏Ïöî. (ÏµúÏÜå {min_bet:,}Ïõê)"))
                self.game_manager.end_game(ctx.author.id)
                return

            await self.gambling_service.subtract_balance(ctx.author.id, bet)
            await self.gambling_service.add_jackpot(bet)

            if secrets.randbelow(100) <= 1:  # 1% ÌôïÎ•†
                winnings = await self.gambling_service.get_jackpot() // 10
                tax = self.gambling_service.calculate_tax(winnings)
                winnings_after_tax = winnings - tax
                await self.gambling_service.add_balance(ctx.author.id, winnings_after_tax)
                await self.gambling_service.subtract_jackpot(winnings)
                self.cooldowns[f"jackpot_win_{ctx.author.id}"] = datetime.now()
                
                embed = discord.Embed(
                    title=f"üéâ {ctx.author.name} ÎãπÏ≤®",
                    description=(
                        f"- ÌòÑÏû¨ Ïû≠Ìåü: {await self.gambling_service.get_jackpot():,}Ïõê(-{winnings:,})\n"
                        f"## ÏàòÏùµ: {winnings_after_tax:,}Ïõê(ÏÑ∏Í∏à: {tax:,}Ïõê)\n"
                        f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê(+{winnings_after_tax:,})"
                    ),
                    color=discord.Color.gold()
                )
            else:
                embed = discord.Embed(
                    title=f"üé∞ {ctx.author.name} Ïû≠Ìåü Ïã§Ìå®„Öã",
                    description=(
                        f"- ÌòÑÏû¨ Ïû≠Ìåü: {await self.gambling_service.get_jackpot():,}Ïõê\n"
                        f"## ÏàòÏùµ: -{bet:,}Ïõê\n"
                        f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                    ),
                    color=discord.Color.red()
                )

            await ctx.reply(embed=embed)
            self.game_manager.end_game(ctx.author.id)

    @commands.command(name="ÎèÑÎ∞ï.ÎÖ∏Îèô", aliases=['ÎèÑÎ∞ï.Ïùº', 'ÎèÑÎ∞ï.Îèà'], description="ÎèÑÎ∞ï.ÎÖ∏Îèô")
    async def work(self, ctx):
        if not self.game_manager.start_game(ctx.author.id, "work"):
            await ctx.reply(embed=GamblingEmbed.create_error_embed("Ïù¥ÎØ∏ Îã§Î•∏ Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§."))
            return

        lock = await self.gambling_service._get_lock(ctx.author.id)
        async with lock:
            current_time = datetime.now()
            last_used = self.cooldowns.get(ctx.author.id)

            if last_used and (current_time - last_used).total_seconds() < GamblingConfig.WORK_COOLDOWN:
                remaining = GamblingConfig.WORK_COOLDOWN - int((current_time - last_used).total_seconds())
                embed = discord.Embed(
                    title="ÌûòÎì§Ïñ¥ÏÑú Ïâ¨Îäî Ï§ë „Öã",
                    description=f"{remaining}Ï¥à ÌõÑÏóê Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.",
                    color=discord.Color.red()
                )
            else:
                amount = random.randint(*GamblingConfig.WORK_REWARD_RANGE)
                await self.gambling_service.add_balance(ctx.author.id, amount)
                embed = discord.Embed(
                    title=f"‚ò≠ {ctx.author.name} ÎÖ∏Îèô",
                    description=(
                        f"Ï†ïÎãπÌïú ÎÖ∏ÎèôÏùÑ ÌÜµÌï¥ {amount:,}ÏõêÏùÑ Î≤åÏóàÎã§.\n"
                        f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê(+{amount:,})"
                    ),
                    color=discord.Color.green()
                )
                self.cooldowns[ctx.author.id] = current_time

            await ctx.reply(embed=embed)
            self.game_manager.end_game(ctx.author.id)

    @commands.command(name="ÎèÑÎ∞ï.ÏßÄÍ∞ë", aliases=['ÎèÑÎ∞ï.ÏûîÏï°', 'ÎèÑÎ∞ï.ÏßÅÎ∞î'], description="ÏûîÏï° ÌôïÏù∏")
    async def balance(self, ctx):
        lock = await self.gambling_service._get_lock(ctx.author.id)
        async with lock:
            balance = await self.gambling_service.get_balance(ctx.author.id)
            embed = discord.Embed(
                title=f"üí∞ {ctx.author.name}Ïùò ÏßÄÍ∞ë",
                description=f"ÌòÑÏû¨ ÏûîÏï°: {balance:,}Ïõê",
                color=discord.Color.blue()
            )
            await ctx.reply(embed=embed)

    @commands.command(name="ÎèÑÎ∞ï.Îû≠ÌÇπ", description="Îû≠ÌÇπ")
    async def ranking(self, ctx):
        async with ctx.typing():
            rankings = await self.gambling_service.get_cached_rankings(self.bot)
            top_3 = rankings[:3]

            description_lines = []
            for i, (_, username, balance) in enumerate(top_3):
                description_lines.append(f"{i+1}. {username}: {balance:,}Ïõê")

            embed = discord.Embed(
                title="üèÖ ÏÉÅÏúÑ 3Î™Ö Îû≠ÌÇπ",
                description="\n".join(description_lines) if description_lines else "Îû≠ÌÇπÏù¥ ÏóÜÏäµÎãàÎã§.",
                color=discord.Color.blue()
            )
            await ctx.reply(embed=embed)

    @commands.command(name="ÎèÑÎ∞ï.Ï†ÑÏ≤¥Îû≠ÌÇπ", description="Ï†ÑÏ≤¥ Îû≠ÌÇπ")
    async def all_ranking(self, ctx):
        async with ctx.typing():
            rankings = await self.gambling_service.get_cached_rankings(self.bot)
            
            if not rankings:
                embed = discord.Embed(
                    title="üèÖ Ï†ÑÏ≤¥ Îû≠ÌÇπ",
                    description="Îû≠ÌÇπ Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§.",
                    color=discord.Color.blue()
                )
                await ctx.reply(embed=embed)
                return

            pages = []
            page_size = 10
            
            # ÌéòÏù¥ÏßÄ ÎØ∏Î¶¨ ÏÉùÏÑ±
            for i in range(0, len(rankings), page_size):
                page_users = rankings[i:i + page_size]
                page_lines = []
                
                for rank, (_, username, balance) in enumerate(page_users, start=i + 1):
                    page_lines.append(f"{rank}. {username}: {balance:,}Ïõê")
                    
                pages.append("\n".join(page_lines))

            current_page = 0
            embed = discord.Embed(
                title="üèÖ Ï†ÑÏ≤¥ Îû≠ÌÇπ",
                description=pages[current_page],
                color=discord.Color.blue()
            )
            embed.set_footer(text=f"{current_page + 1}/{len(pages)}")

            message = await ctx.reply(embed=embed)

            if len(pages) > 1:
                await message.add_reaction("‚óÄÔ∏è")
                await message.add_reaction("‚ñ∂Ô∏è")

                def check(reaction, user):
                    return (user == ctx.author and 
                            str(reaction.emoji) in ["‚óÄÔ∏è", "‚ñ∂Ô∏è"] and 
                            reaction.message.id == message.id)

                while True:
                    try:
                        reaction, user = await self.bot.wait_for(
                            "reaction_add",
                            timeout=30.0,
                            check=check
                        )

                        if str(reaction.emoji) == "‚ñ∂Ô∏è" and current_page < len(pages) - 1:
                            current_page += 1
                        elif str(reaction.emoji) == "‚óÄÔ∏è" and current_page > 0:
                            current_page -= 1

                        embed.description = pages[current_page]
                        embed.set_footer(text=f"{current_page + 1}/{len(pages)}")
                        await message.edit(embed=embed)
                        await message.remove_reaction(reaction, user)

                    except asyncio.TimeoutError:
                        await message.clear_reactions()
                        break

    @commands.command(name="ÎèÑÎ∞ï.ÏÜ°Í∏à", description="ÏÜ°Í∏à")
    async def transfer(self, ctx, recipient: discord.Member = None, amount: str = None):
        if recipient is None or amount is None:
            await ctx.reply(embed=GamblingEmbed.create_error_embed("!ÎèÑÎ∞ï.ÏÜ°Í∏à [Ïú†Ï†Ä] [Í∏àÏï°] <-- Ïù¥Î†áÍ≤å Ïç®"))
            return

        try:
            amount = int(amount) if amount != "Ïò¨Ïù∏" else await self.gambling_service.get_balance(ctx.author.id)
        except ValueError:
            await ctx.reply(embed=GamblingEmbed.create_error_embed("Ïò¨Î∞îÎ•∏ Í∏àÏï°ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî"))
            return

        if amount <= GamblingConfig.MIN_JACKPOT_BET:
            await ctx.reply(embed=GamblingEmbed.create_error_embed("1,000Ïõê Ïù¥ÌïòÎäî ÏÜ°Í∏àÌï† Ïàò ÏóÜÏäµÎãàÎã§."))
            return

        if amount >= GamblingConfig.MAX_BET:
            await ctx.reply(embed=GamblingEmbed.create_error_embed("100Ï°∞Ïõê Ïù¥ÏÉÅ ÏÜ°Í∏àÌï† Ïàò ÏóÜÏäµÎãàÎã§"))
            return

        sender_lock = await self.gambling_service._get_lock(ctx.author.id)
        recipient_lock = await self.gambling_service._get_lock(recipient.id)
        
        async with sender_lock:
            async with recipient_lock:
                sender_balance = await self.gambling_service.get_balance(ctx.author.id)

                if amount > sender_balance:
                    await ctx.reply(embed=GamblingEmbed.create_error_embed("ÎèàÏù¥ Î∂ÄÏ°±Ìï¥..."))
                    return

                tax = self.gambling_service.calculate_gift_tax(amount)
                amount_after_tax = amount - tax

                await self.gambling_service.subtract_balance(ctx.author.id, amount)
                await self.gambling_service.add_balance(recipient.id, amount_after_tax)
                await self.gambling_service.add_jackpot(tax)

                embed = discord.Embed(
                    title="üí∏ ÏÜ°Í∏à ÏôÑÎ£å",
                    description=(
                        f"{ctx.author.name} ‚Üí {recipient.name}\n"
                        f"## {amount:,}Ïõê ÏÜ°Í∏à(ÏÑ∏Í∏à: {tax:,}Ïõê)\n"
                        f"- ÏûîÏï°: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                    ),
                    color=discord.Color.green()
                )

                await ctx.reply(embed=embed)

    @commands.command(name="ÎèÑÎ∞ï.Î∏îÎûôÏû≠", description="Î∏îÎûôÏû≠")
    async def blackjack(self, ctx, bet: str = None):
        if cooldown_embed := self._check_game_cooldown(ctx.author.id, "blackjack"):
            await ctx.reply(embed=cooldown_embed)
            return

        try:
            bet = int(bet) if bet != "Ïò¨Ïù∏" else await self.gambling_service.get_balance(ctx.author.id)
        except (ValueError, TypeError):
            bet = None

        if error_embed := self.gambling_service.validate_bet(bet, ctx.author.id):
            await ctx.reply(embed=error_embed)
            return

        if bet > await self.gambling_service.get_balance(ctx.author.id):
            await ctx.reply(embed=GamblingEmbed.create_error_embed("ÎèàÏù¥ Î∂ÄÏ°±Ìï¥..."))
            return

        self.blackjack_players.add(ctx.author.id)

        try:
            cards = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'] * 4
            random.shuffle(cards)

            player_hand = [cards.pop(), cards.pop()]
            dealer_hand = [cards.pop(), cards.pop()]

            player_value = self.gambling_service.calculate_hand_value(player_hand)
            dealer_value = self.gambling_service.calculate_hand_value(dealer_hand)

            embed = discord.Embed(
                title=f"üÉè {ctx.author.name}Ïùò Î∏îÎûôÏû≠",
                description=f"{ctx.author.name}Ïùò Ìå®: {' '.join(player_hand)} (Ìï©Í≥Ñ: {player_value})\nJEE6Ïùò Ìå®: {dealer_hand[0]} ?",
                color=discord.Color.blue()
            )
            embed.add_field(name="ÏÑ†ÌÉù", value="üëä Hit / üõë Stand", inline=False)

            game_message = await ctx.reply(embed=embed)
            await game_message.add_reaction("üëä")
            await game_message.add_reaction("üõë")

            def check(reaction, user):
                return (user == ctx.author and 
                       str(reaction.emoji) in ["üëä", "üõë"] and 
                       reaction.message.id == game_message.id)

            while True:
                try:
                    reaction, user = await self.bot.wait_for('reaction_add', timeout=30.0, check=check)
                    await reaction.remove(user)

                    if str(reaction.emoji) == "üëä":
                        player_hand.append(cards.pop())
                        player_value = self.gambling_service.calculate_hand_value(player_hand)

                        if player_value > 21:
                            with await self.gambling_service._get_lock(ctx.author.id):
                                await self.gambling_service.subtract_balance(ctx.author.id, bet)

                            embed = discord.Embed(
                                title=f"üÉè {ctx.author.name} Î≤ÑÏä§Ìä∏!",
                                description=(
                                    f"{ctx.author.name}Ïùò Ìå®: {' '.join(player_hand)} (Ìï©Í≥Ñ: {player_value})\n"
                                    f"JEE6Ïùò Ìå®: {' '.join(dealer_hand)} (Ìï©Í≥Ñ: {dealer_value})\n"
                                    f"## ÏàòÏùµ: {bet:,}Ïõê √ó -1 = -{bet:,}Ïõê\n"
                                    f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                                ),
                                color=discord.Color.red()
                            )
                            await game_message.edit(embed=embed)
                            return

                        embed = discord.Embed(
                            title=f"üÉè {ctx.author.name}Ïùò Î∏îÎûôÏû≠",
                            description=(
                                f"{ctx.author.name}Ïùò Ìå®: {' '.join(player_hand)} (Ìï©Í≥Ñ: {player_value})\n"
                                f"JEE6Ïùò Ìå®: {dealer_hand[0]} ?"
                            ),
                            color=discord.Color.blue()
                        )
                        embed.add_field(name="ÏÑ†ÌÉù", value="üëä Hit ÎòêÎäî üõë Stand", inline=False)
                        await game_message.edit(embed=embed)

                    elif str(reaction.emoji) == "üõë":
                        while dealer_value < 17:
                            dealer_hand.append(cards.pop())
                            dealer_value = self.gambling_service.calculate_hand_value(dealer_hand)

                        with await self.gambling_service._get_lock(ctx.author.id):
                            if dealer_value > 21 or player_value > dealer_value:
                                multiplier = 2.0 if player_value == 21 else random.uniform(*GamblingConfig.GAME_MULTIPLIER_RANGES["blackjack"])
                                winnings = int(bet * multiplier)
                                tax = self.gambling_service.calculate_tax(winnings, "blackjack")
                                winnings_after_tax = winnings - tax
                                await self.gambling_service.add_balance(ctx.author.id, winnings_after_tax)

                                embed = discord.Embed(
                                    title=f"üÉè {ctx.author.name} ÏäπÎ¶¨",
                                    description=(
                                        f"{ctx.author.name}Ïùò Ìå®: {' '.join(player_hand)} (Ìï©Í≥Ñ: {player_value})\n"
                                        f"JEE6Ïùò Ìå®: {' '.join(dealer_hand)} (Ìï©Í≥Ñ: {dealer_value})\n"
                                        f"## ÏàòÏùµ: {bet:,}Ïõê √ó {multiplier:.2f} = {winnings:,}Ïõê(ÏÑ∏Í∏à: {tax:,}Ïõê)\n"
                                        f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                                    ),
                                    color=discord.Color.green()
                                )
                            else:
                                await self.gambling_service.subtract_balance(ctx.author.id, bet)
                                embed = discord.Embed(
                                    title=f"üÉè {ctx.author.name} {'Ìå®Î∞∞' if player_value < dealer_value else 'Î¨¥ÏäπÎ∂Ä'}",
                                    description=(
                                        f"{ctx.author.name}Ïùò Ìå®: {' '.join(player_hand)} (Ìï©Í≥Ñ: {player_value})\n"
                                        f"JEE6Ïùò Ìå®: {' '.join(dealer_hand)} (Ìï©Í≥Ñ: {dealer_value})\n"
                                        f"## ÏàòÏùµ: {bet:,}Ïõê √ó -1 = -{bet:,}Ïõê\n"
                                        f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                                    ),
                                    color=discord.Color.red()
                                )

                            await game_message.edit(embed=embed)
                            return

                except asyncio.TimeoutError:
                    with await self.gambling_service._get_lock(ctx.author.id):
                        await self.gambling_service.subtract_balance(ctx.author.id, bet)
                        embed = discord.Embed(
                            title="‚è≥Ô∏è ÏãúÍ∞Ñ Ï¥àÍ≥º",
                            description=f"30Ï¥à ÎèôÏïà ÏùëÎãµÏù¥ ÏóÜÏñ¥ Î≤†ÌåÖÍ∏à {bet:,}ÏõêÏùÑ ÏûÉÏóàÏäµÎãàÎã§.\n- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê",
                            color=discord.Color.red()
                        )
                    await game_message.edit(embed=embed)
                    return

        finally:
            self.blackjack_players.remove(ctx.author.id)

    @commands.command(name="ÎèÑÎ∞ï.Î∞îÏπ¥Îùº", description="Î∞îÏπ¥Îùº")
    async def baccarat(self, ctx, bet: str = None):
        if cooldown_embed := self._check_game_cooldown(ctx.author.id, "baccarat"):
            await ctx.reply(embed=cooldown_embed)
            return

        try:
            bet = int(bet) if bet != "Ïò¨Ïù∏" else await self.gambling_service.get_balance(ctx.author.id)
        except (ValueError, TypeError):
            bet = None

        if error_embed := self.gambling_service.validate_bet(bet, ctx.author.id):
            await ctx.reply(embed=error_embed)
            return

        if bet > await self.gambling_service.get_balance(ctx.author.id):
            await ctx.reply(embed=GamblingEmbed.create_error_embed("ÎèàÏù¥ Î∂ÄÏ°±Ìï¥..."))
            return

        self.baccarat_players.add(ctx.author.id)

        try:
            embed = discord.Embed(
                title=f"üÉè {ctx.author.name}Ïùò Î∞îÏπ¥Îùº",
                description="Î≤†ÌåÖÌï† Í≥≥ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî",
                color=discord.Color.blue()
            )
            embed.add_field(name="ÏÑ†ÌÉù", value=f"üë§ Player: {ctx.author.name} / üè¶ Banker: JEE6 / ü§ù Tie", inline=False)

            game_message = await ctx.reply(embed=embed)
            await game_message.add_reaction("üë§")
            await game_message.add_reaction("üè¶")
            await game_message.add_reaction("ü§ù")

            def check(reaction, user):
                return (user == ctx.author and 
                       str(reaction.emoji) in ["üë§", "üè¶", "ü§ù"] and 
                       reaction.message.id == game_message.id)

            try:
                reaction, user = await self.bot.wait_for('reaction_add', timeout=30.0, check=check)

                guess = {"üë§": "Player", "üè¶": "Banker", "ü§ù": "Tie"}[str(reaction.emoji)]

                cards = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'] * 4
                random.shuffle(cards)

                player_hand = [cards.pop(), cards.pop()]
                banker_hand = [cards.pop(), cards.pop()]

                player_value = self.gambling_service.calculate_baccarat_value(player_hand)
                banker_value = self.gambling_service.calculate_baccarat_value(banker_hand)

                if player_value <= 5:
                    player_hand.append(cards.pop())
                    player_value = self.gambling_service.calculate_baccarat_value(player_hand)

                if banker_value <= 5:
                    banker_hand.append(cards.pop())
                    banker_value = self.gambling_service.calculate_baccarat_value(banker_hand)

                if player_value > banker_value:
                    result = "Player"
                elif banker_value > player_value:
                    result = "Banker"
                else:
                    result = "Tie"

                with await self.gambling_service._get_lock(ctx.author.id):
                    if guess == result:
                        multiplier = 8 if result == "Tie" else random.uniform(*GamblingConfig.GAME_MULTIPLIER_RANGES["baccarat"])
                        winnings = int(bet * multiplier)
                        tax = self.gambling_service.calculate_tax(winnings, "baccarat")
                        winnings_after_tax = winnings - tax
                        await self.gambling_service.add_balance(ctx.author.id, winnings_after_tax - bet)

                        embed = discord.Embed(
                            title=f"üÉè {ctx.author.name} ÎßûÏùå „Ñπ„Öà„Ñ∑",
                            description=(
                                f"{ctx.author.name}: {' '.join(player_hand)} (Ìï©Í≥Ñ: {player_value})\n"
                                f"JEE6: {' '.join(banker_hand)} (Ìï©Í≥Ñ: {banker_value})\n"
                                f"## ÏàòÏùµ: {bet:,}Ïõê √ó {multiplier:.2f} = {winnings:,}Ïõê(ÏÑ∏Í∏à: {tax:,}Ïõê)\n"
                                f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                            ),
                            color=discord.Color.green()
                        )
                    else:
                        await self.gambling_service.subtract_balance(ctx.author.id, bet)
                        embed = discord.Embed(
                            title=f"üÉè {ctx.author.name} ÌãÄÎ¶º„Öã",
                            description=(
                                f"{ctx.author.name}: {' '.join(player_hand)} (Ìï©Í≥Ñ: {player_value})\n"
                                f"JEE6: {' '.join(banker_hand)} (Ìï©Í≥Ñ: {banker_value})\n"
                                f"## ÏàòÏùµ: {bet:,}Ïõê √ó -1 = -{bet:,}Ïõê\n"
                                f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                            ),
                            color=discord.Color.red()
                        )

                    await game_message.edit(embed=embed)

            except asyncio.TimeoutError:
                with await self.gambling_service._get_lock(ctx.author.id):
                    await self.gambling_service.subtract_balance(ctx.author.id, bet)
                    embed = discord.Embed(
                        title="‚è≥Ô∏è ÏãúÍ∞Ñ Ï¥àÍ≥º",
                        description=f"30Ï¥à ÎèôÏïà ÏùëÎãµÏù¥ ÏóÜÏñ¥ Î≤†ÌåÖÍ∏à {bet:,}ÏõêÏùÑ ÏûÉÏóàÏäµÎãàÎã§.\n- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê",
                        color=discord.Color.red()
                    )
                await game_message.edit(embed=embed)

        finally:
            self.baccarat_players.remove(ctx.author.id)

    @commands.command(name="ÎèÑÎ∞ï.Ïù∏ÎîîÏñ∏", aliases=['ÎèÑÎ∞ï.Ïù∏ÎîîÏñ∏Ìè¨Ïª§'], description="Ïù∏ÎîîÏñ∏ Ìè¨Ïª§")
    async def indian_poker(self, ctx, bet: str = None):
        if cooldown_embed := self._check_game_cooldown(ctx.author.id, "indian_poker"):
            await ctx.reply(embed=cooldown_embed)
            return

        try:
            bet = int(bet) if bet != "Ïò¨Ïù∏" else await self.gambling_service.get_balance(ctx.author.id)
        except (ValueError, TypeError):
            bet = None

        if error_embed := self.gambling_service.validate_bet(bet, ctx.author.id):
            await ctx.reply(embed=error_embed)
            return

        if bet > await self.gambling_service.get_balance(ctx.author.id):
            await ctx.reply(embed=GamblingEmbed.create_error_embed("ÎèàÏù¥ Î∂ÄÏ°±Ìï¥..."))
            return

        self.indian_poker_players.add(ctx.author.id)

        try:
            player_card = random.randint(1, 10)
            banker_card = random.randint(1, 10)

            embed = discord.Embed(
                title=f"üÉè {ctx.author.name}Ïùò Ïù∏ÎîîÏñ∏ Ìè¨Ïª§",
                description=f"{ctx.author.name}Ïùò Ïπ¥Îìú: ?\nJEE6Ïùò Ïπ¥Îìú: {banker_card}",
                color=discord.Color.blue()
            )
            embed.add_field(name="ÏÑ†ÌÉù", value="üíÄ Die / ‚úÖ Call", inline=False)

            game_message = await ctx.reply(embed=embed)
            await game_message.add_reaction("üíÄ")
            await game_message.add_reaction("‚úÖ")

            def check(reaction, user):
                return (user == ctx.author and 
                       str(reaction.emoji) in ["üíÄ", "‚úÖ"] and 
                       reaction.message.id == game_message.id)

            try:
                reaction, user = await self.bot.wait_for('reaction_add', timeout=30.0, check=check)

                with await self.gambling_service._get_lock(ctx.author.id):
                    if str(reaction.emoji) == "üíÄ":  # Îã§Ïù¥
                        loss = bet // 2
                        await self.gambling_service.subtract_balance(ctx.author.id, loss)
                        embed = discord.Embed(
                            title=f"üÉè {ctx.author.name} Die",
                            description=(
                                f"{ctx.author.name}Ïùò Ïπ¥Îìú: {player_card}\n"
                                f"JEE6Ïùò Ïπ¥Îìú: {banker_card}\n"
                                f"## ÏàòÏùµ: {bet:,}Ïõê √ó -0.5 = -{loss:,}Ïõê\n"
                                f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                            ),
                            color=discord.Color.red()
                        )
                    else:  # ÏΩú
                        if player_card > banker_card:
                            multiplier = random.uniform(*GamblingConfig.GAME_MULTIPLIER_RANGES["indian_poker"])
                            winnings = int(bet * multiplier)
                            tax = self.gambling_service.calculate_tax(winnings, "indian_poker")
                            winnings_after_tax = winnings - tax
                            await self.gambling_service.add_balance(ctx.author.id, winnings_after_tax)
                            embed = discord.Embed(
                                title=f"üÉè {ctx.author.name} ÏäπÎ¶¨",
                                description=(
                                    f"{ctx.author.name}Ïùò Ïπ¥Îìú: {player_card}\n"
                                    f"JEE6Ïùò Ïπ¥Îìú: {banker_card}\n"
                                    f"## ÏàòÏùµ: {bet:,}Ïõê √ó {multiplier:.2f} = {winnings:,}Ïõê(ÏÑ∏Í∏à: {tax:,}Ïõê)\n"
                                    f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                                ),
                                color=discord.Color.green()
                            )
                        else:
                            await self.gambling_service.subtract_balance(ctx.author.id, bet)
                            embed = discord.Embed(
                                title=f"üÉè {ctx.author.name} Ìå®Î∞∞",
                                description=(
                                    f"{ctx.author.name}Ïùò Ïπ¥Îìú: {player_card}\n"
                                    f"JEE6Ïùò Ïπ¥Îìú: {banker_card}\n"
                                    f"## ÏàòÏùµ: {bet:,}Ïõê √ó -1 = -{bet:,}Ïõê\n"
                                    f"- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê"
                                ),
                                color=discord.Color.red()
                            )

                    await game_message.edit(embed=embed)

            except asyncio.TimeoutError:
                with await self.gambling_service._get_lock(ctx.author.id):
                    await self.gambling_service.subtract_balance(ctx.author.id, bet)
                    embed = discord.Embed(
                        title="‚è≥Ô∏è ÏãúÍ∞Ñ Ï¥àÍ≥º",
                        description=f"30Ï¥à ÎèôÏïà ÏùëÎãµÏù¥ ÏóÜÏñ¥ Î≤†ÌåÖÍ∏à {bet:,}ÏõêÏùÑ ÏûÉÏóàÏäµÎãàÎã§.\n- Ïû¨ÏÇ∞: {await self.gambling_service.get_balance(ctx.author.id):,}Ïõê",
                        color=discord.Color.red()
                    )
                await game_message.edit(embed=embed)

        finally:
            self.indian_poker_players.remove(ctx.author.id)

    async def cog_check(self, ctx):
        if ctx.author.id in (self.blackjack_players | self.baccarat_players | 
                           self.indian_poker_players | self.coin_players | self.dice_players):
            
            current_game = None
            if ctx.author.id in self.blackjack_players:
                current_game = "Î∏îÎûôÏû≠"
            elif ctx.author.id in self.baccarat_players:
                current_game = "Î∞îÏπ¥Îùº" 
            elif ctx.author.id in self.indian_poker_players:
                current_game = "Ïù∏ÎîîÏñ∏ Ìè¨Ïª§"
            elif ctx.author.id in self.coin_players:
                current_game = "ÎèôÏ†Ñ"
            elif ctx.author.id in self.dice_players:
                current_game = "Ï£ºÏÇ¨ÏúÑ"
                
            await ctx.reply(embed=GamblingEmbed.create_error_embed(f"Ïù¥ÎØ∏ {current_game} Í≤åÏûÑÏù¥ ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§."))
            return False
            
        return True